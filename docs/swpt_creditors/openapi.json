{
  "info": {
    "description": "In order to allow currency holders to use client applications of\ntheir choice, Swaptacular recommends this `Payments Web API`.  The API\nallows for efficient client-side caching, as well as efficient cache\nand data synchronization between two or more clients.\n\nNote that every potentially dangerous operation, that the creditor is\nallowed to perform via this API, can optionally be protected by a PIN\n(Personal Identification Number). This allows users to stay logged in\nfor a long time, without compromising the security of their wallets.\n\nThis API is organized in four separate sections: **admin**,\n**creditors**, **accounts**, **transfers**.",
    "title": "Creditors API",
    "version": "v1"
  },
  "servers": [
    {
      "url": "https://demo.swaptacular.org/"
    },
    {
      "url": "/"
    }
  ],
  "components": {
    "securitySchemes": {
      "oauth2": {
        "type": "oauth2",
        "description": "This API uses OAuth 2. [More info](https://oauth.net/2/).",
        "flows": {
          "authorizationCode": {
            "authorizationUrl": "https://demo.swaptacular.org/creditors-hydra/oauth2/auth",
            "tokenUrl": "https://demo.swaptacular.org/creditors-hydra/oauth2/token",
            "refreshUrl": "https://demo.swaptacular.org/creditors-hydra/oauth2/token",
            "scopes": {
              "access.readonly": "read-only access",
              "access": "read-write access",
              "disable_pin": "disable the Personal Identification Number"
            }
          },
          "clientCredentials": {
            "tokenUrl": "https://demo.swaptacular.org/creditors-hydra/oauth2/token",
            "refreshUrl": "https://demo.swaptacular.org/creditors-hydra/oauth2/token",
            "scopes": {
              "access.readonly": "read-only access",
              "access": "read-write access",
              "disable_pin": "disable the Personal Identification Number",
              "activate": "activate new creditors",
              "deactivate": "deactivate existing creditors"
            }
          }
        }
      }
    },
    "schemas": {
      "Error": {
        "type": "object",
        "properties": {
          "errors": {
            "type": "object",
            "description": "Errors"
          },
          "status": {
            "type": "string",
            "description": "Error name"
          },
          "message": {
            "type": "string",
            "description": "Error message"
          },
          "code": {
            "type": "integer",
            "description": "Error code"
          }
        }
      },
      "PaginationMetadata": {
        "type": "object",
        "properties": {
          "total": {
            "type": "integer"
          },
          "total_pages": {
            "type": "integer"
          },
          "first_page": {
            "type": "integer"
          },
          "last_page": {
            "type": "integer"
          },
          "page": {
            "type": "integer"
          },
          "previous_page": {
            "type": "integer"
          },
          "next_page": {
            "type": "integer"
          }
        }
      },
      "CreditorReservationRequest": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "default": "CreditorReservationRequest",
            "writeOnly": true,
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CreditorReservationRequest"
          }
        }
      },
      "CreditorReservation": {
        "type": "object",
        "properties": {
          "validUntil": {
            "readOnly": true,
            "type": "string",
            "format": "date-time",
            "description": "The moment at which the reservation will expire."
          },
          "creditorId": {
            "readOnly": true,
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$",
            "description": "The reserved creditor ID.",
            "example": "1"
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the reservation was created."
          },
          "reservationId": {
            "readOnly": true,
            "maxLength": 100,
            "type": "string",
            "description": "An opaque string that will be required in order to successfully activate the creditor.",
            "example": "12345"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CreditorReservation"
          }
        },
        "required": [
          "createdAt",
          "creditorId",
          "reservationId",
          "type",
          "validUntil"
        ]
      },
      "CreditorsList": {
        "type": "object",
        "properties": {
          "itemsType": {
            "type": "string",
            "readOnly": true,
            "description": "The type of the items in the paginated list.",
            "example": "string"
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/.list"
          },
          "first": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of the first page in the paginated list. This can be a relative URI. The object retrieved from this URI will have: 1) An `items` field (an array), which will contain the first items of the paginated list; 2) May have a `next` field (a string), which would contain the URI of the next page in the list.",
            "example": "/list?page=1"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CreditorsList"
          }
        },
        "required": [
          "first",
          "itemsType",
          "type",
          "uri"
        ]
      },
      "ObjectReference": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "format": "uri-reference",
            "description": "The URI of the object. Can be a relative URI.",
            "example": "https://example.com/objects/1"
          }
        },
        "required": [
          "uri"
        ]
      },
      "ObjectReferencesPage": {
        "type": "object",
        "properties": {
          "next": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "An URI of another `ObjectReferencesPage` object which contains more items. When there are no remaining items, this field will not be present. If this field is present, there might be remaining items, even when the `items` array is empty. This can be a relative URI.",
            "example": "?prev=111"
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/"
          },
          "items": {
            "readOnly": true,
            "description": "An array of `ObjectReference`s. Can be empty.",
            "example": [
              {
                "uri": "1/"
              },
              {
                "uri": "11/"
              },
              {
                "uri": "111/"
              }
            ],
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ObjectReference"
            }
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "ObjectReferencesPage"
          }
        },
        "required": [
          "items",
          "type",
          "uri"
        ]
      },
      "CreditorActivationRequest": {
        "type": "object",
        "properties": {
          "reservationId": {
            "type": "string",
            "writeOnly": true,
            "description": "When this field is present, the server will try to activate an existing reservation with matching `creditorID` and `reservationID`.\n\nWhen this field is not present, the server will try to reserve the creditor ID specified in the path, and activate it at once.",
            "example": "12345"
          },
          "type": {
            "type": "string",
            "default": "CreditorActivationRequest",
            "writeOnly": true,
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CreditorActivationRequest"
          }
        }
      },
      "Creditor": {
        "type": "object",
        "properties": {
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the creditor was created."
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "type": {
            "type": "string",
            "default": "Creditor",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "Creditor"
          },
          "wallet": {
            "readOnly": true,
            "description": "The URI of the creditor's `Wallet`.",
            "example": {
              "uri": "/creditors/2/wallet"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/"
          }
        },
        "required": [
          "createdAt",
          "latestUpdateAt",
          "latestUpdateId",
          "uri",
          "wallet"
        ]
      },
      "CreditorDeactivationRequest": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "default": "CreditorDeactivationRequest",
            "writeOnly": true,
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CreditorDeactivationRequest"
          }
        }
      },
      "PaginatedStream": {
        "type": "object",
        "properties": {
          "itemsType": {
            "type": "string",
            "readOnly": true,
            "description": "The type of the items in the paginated stream.",
            "example": "string"
          },
          "forthcoming": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "An URI for obtaining items that might be added to the paginated stream in the future. This is useful when the client wants to skip all items currently in the stream, but to follow the forthcoming stream of new items. The object retrieved from this URI will be of the same type as the one retrieved from the `first` field. This can be a relative URI.",
            "example": "/stream?page=1000"
          },
          "first": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of the first page in the paginated stream. This can be a relative URI. The object retrieved from this URI will have: 1) An `items` field (an array), which will contain the first items of the paginated stream; 2) May have a `next` field (a string), which would contain the URI of the next page in the stream; 3) If the `next` field is not present, will have a `forthcoming` field, for obtaining items that might be added to the stream in the future.",
            "example": "/stream?page=1"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "PaginatedStream"
          }
        },
        "required": [
          "first",
          "forthcoming",
          "itemsType",
          "type"
        ]
      },
      "Wallet": {
        "type": "object",
        "properties": {
          "createAccount": {
            "readOnly": true,
            "description": "A URI to which a `DebtorIdentity` object can be POST-ed to create a new `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "debtorLookup": {
            "readOnly": true,
            "description": "A URI to which a `DebtorIdentity` object can be POST-ed, trying to find an existing account with this debtor. If an existing account is found, the response will redirect to the `Account` (response code 303). Otherwise, the response will be empty (response code 204).",
            "example": {
              "uri": "/creditors/2/debtor-lookup"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "creditor": {
            "readOnly": true,
            "description": "The URI of the `Creditor`.",
            "example": {
              "uri": "/creditors/2/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "requirePin": {
            "type": "boolean",
            "readOnly": true,
            "description": "Whether the PIN is required for potentially dangerous operations.\n\n**Note:** The PIN will never be required when in \"PIN reset\" mode.",
            "example": true
          },
          "logLatestEntryId": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The ID of the latest entry in the creditor's log stream. If there are no entries yet, the value will be `0`.",
            "example": 12345
          },
          "accountsList": {
            "readOnly": true,
            "description": "The URI of creditor's `AccountsList`. In other words: an URI of a paginated list of `ObjectReference`s to all `Account`s belonging to the creditor. The paginated list will not be sorted in any particular order.",
            "example": {
              "uri": "/creditors/2/accounts-list"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "log": {
            "readOnly": true,
            "description": "A `PaginatedStream` of creditor's `LogEntry`s. The paginated stream will be sorted in chronological order (smaller entry IDs go first). The main purpose of the log stream is to allow the clients of the API to reliably and efficiently invalidate their caches, simply by following the \"log\".",
            "example": {
              "first": "/creditors/2/log",
              "forthcoming": "/creditors/2/log?prev=12345",
              "itemsType": "LogEntry",
              "type": "PaginatedStream"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginatedStream"
              }
            ]
          },
          "pinInfo": {
            "readOnly": true,
            "description": "The URI of creditor's `PinInfo`.",
            "example": {
              "uri": "/creditors/2/pin"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "transfersList": {
            "readOnly": true,
            "description": "The URI of creditor's `TransfersList`. In other words: an URI of a paginated list of `ObjectReference`s to all `Transfer`s initiated by the creditor, which have not been deleted yet. The paginated list will not be sorted in any particular order.",
            "example": {
              "uri": "/creditors/2/transfers-list"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "Wallet"
          },
          "accountLookup": {
            "readOnly": true,
            "description": "A URI to which the recipient account's `AccountIdentity` can be POST-ed, trying to find the identify of the account's debtor. If the debtor has been identified successfully, the response will contain the debtor's `DebtorIdentity`. Otherwise, the response code will be 422.",
            "example": {
              "uri": "/creditors/2/account-lookup"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/wallet"
          },
          "logRetentionDays": {
            "readOnly": true,
            "type": "integer",
            "format": "int32",
            "description": "The entries in the creditor's log stream will not be deleted for at least this number of days. Must be at least 30 days.",
            "example": 30
          },
          "createTransfer": {
            "readOnly": true,
            "description": "A URI to which a `TransferCreationRequest` can be POST-ed to create a new `Transfer`.",
            "example": {
              "uri": "/creditors/2/transfers/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          }
        },
        "required": [
          "accountLookup",
          "accountsList",
          "createAccount",
          "createTransfer",
          "creditor",
          "debtorLookup",
          "log",
          "logLatestEntryId",
          "logRetentionDays",
          "pinInfo",
          "requirePin",
          "transfersList",
          "type",
          "uri"
        ]
      },
      "PinInfo": {
        "type": "object",
        "properties": {
          "newPin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "The new PIN. When `status` is \"on\", this field must be present. Note that when changing the PIN, the `pin` field should contain the old PIN, and the `newPin` field should contain the new PIN.",
            "example": "5678"
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "type": "string",
            "default": "PinInfo",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "PinInfo"
          },
          "status": {
            "type": "string",
            "pattern": "^(off|on|blocked)$",
            "description": "The status of the PIN.\n\n* `\"off\"` means that the PIN is not required for potentially   dangerous operations.\n* `\"on\"` means that the PIN is required for potentially dangerous   operations.\n* `\"blocked\"` means that the PIN has been blocked.",
            "example": "on"
          },
          "wallet": {
            "readOnly": true,
            "description": "The URI of the creditor's `Wallet`.",
            "example": {
              "uri": "/creditors/2/wallet"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/pin"
          }
        },
        "required": [
          "latestUpdateAt",
          "latestUpdateId",
          "status",
          "uri",
          "wallet"
        ]
      },
      "LogEntry": {
        "type": "object",
        "properties": {
          "objectType": {
            "readOnly": true,
            "type": "string",
            "description": "The type of the object that has been created, updated, or deleted.",
            "example": "Account"
          },
          "object": {
            "readOnly": true,
            "description": "The URI of the object that has been created, updated, or deleted.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "addedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the entry was added to the log."
          },
          "entryId": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The ID of the log entry. This will always be a positive number. The ID of the first log entry can by any positive number, but the IDs of all subsequent log entries will be equal to the ID of the previous log entry plus one.",
            "example": 12345
          },
          "data": {
            "type": "object",
            "readOnly": true,
            "description": "Optional information about the new state of the created/updated object. When present, this information can be used to avoid making a network request to obtain the new state. What properties the \"data\" object will have, depends on the value of the `objectType` field:\n\n### When the object type is \"AccountLedger\"\n`principal`, `nextEntryId`, and `firstPage` properties will  be present. The `firstPage` property will contain the value of the `entries.first` field from the corresponding account ledger object.\n\n### When the object type is \"Transfer\"\nIf the transfer is finalized, `finalizedAt` and (only when there is an error) `errorCode` properties will be present. If the transfer is not finalized, the \"data\" object will not be present.\n\n**Note:** This field will never be present when the object has been deleted."
          },
          "deleted": {
            "readOnly": true,
            "type": "boolean",
            "description": "Whether the object has been deleted.",
            "example": false
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "LogEntry"
          },
          "objectUpdateId": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "A positive number which gets bigger after each change in the object. When this field is not present, this means that either the object is *immutable*, or it has been *deleted permanently*. For mutable objects which can be deleted and re-created with the same URI (accounts for example), this field will be present even when the `deleted` field is `true`.",
            "example": 10
          }
        },
        "required": [
          "addedAt",
          "deleted",
          "entryId",
          "object",
          "objectType",
          "type"
        ]
      },
      "LogEntriesPage": {
        "type": "object",
        "properties": {
          "next": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "An URI of another `LogEntriesPage` object which contains more items. When there are no remaining items, this field will not be present. If this field is present, there might be remaining items, even when the `items` array is empty. This can be a relative URI.",
            "example": "?prev=12345"
          },
          "items": {
            "readOnly": true,
            "description": "An array of `LogEntry`s. Can be empty.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LogEntry"
            }
          },
          "forthcoming": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "An URI of another `LogEntriesPage` object which would contain items that might be added in the future. That is: items that are not currently available, but may become available in the future. This is useful when we want to follow a continuous stream of log entries. This field will not be present if, and only if, the `next` field is present. This can be a relative URI.",
            "example": "?prev=12345"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "LogEntriesPage"
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/log"
          }
        },
        "required": [
          "items",
          "type",
          "uri"
        ]
      },
      "AccountsList": {
        "type": "object",
        "properties": {
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "first": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of the first page in the paginated list. This can be a relative URI. The object retrieved from this URI will have: 1) An `items` field (an array), which will contain the first items of the paginated list; 2) May have a `next` field (a string), which would contain the URI of the next page in the list.",
            "example": "/list?page=1"
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "itemsType": {
            "type": "string",
            "readOnly": true,
            "description": "The type of the items in the paginated list.",
            "example": "string"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountsList"
          },
          "wallet": {
            "readOnly": true,
            "description": "The URI of the creditor's `Wallet` that contains the accounts list.",
            "example": {
              "uri": "/creditors/2/wallet"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts-list"
          }
        },
        "required": [
          "first",
          "itemsType",
          "latestUpdateAt",
          "latestUpdateId",
          "type",
          "uri",
          "wallet"
        ]
      },
      "TransfersList": {
        "type": "object",
        "properties": {
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "first": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of the first page in the paginated list. This can be a relative URI. The object retrieved from this URI will have: 1) An `items` field (an array), which will contain the first items of the paginated list; 2) May have a `next` field (a string), which would contain the URI of the next page in the list.",
            "example": "/list?page=1"
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "itemsType": {
            "type": "string",
            "readOnly": true,
            "description": "The type of the items in the paginated list.",
            "example": "string"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransfersList"
          },
          "wallet": {
            "readOnly": true,
            "description": "The URI of the creditor's `Wallet` that contains the transfers list.",
            "example": {
              "uri": "/creditors/2/wallet"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/transfers-list"
          }
        },
        "required": [
          "first",
          "itemsType",
          "latestUpdateAt",
          "latestUpdateId",
          "type",
          "uri",
          "wallet"
        ]
      },
      "AccountIdentity": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "maxLength": 200,
            "format": "uri",
            "description": "The information contained in this field must be enough to: 1) uniquely and reliably identify the debtor, 2) uniquely and reliably identify the creditor's account with the debtor. Note that a network request *should not be needed* to identify the account.\n\nFor example, if the debtor happens to be a bank, the URI would reveal the type of the debtor (a bank), the ID of the bank, and the bank account number."
          },
          "type": {
            "type": "string",
            "default": "AccountIdentity",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountIdentity"
          }
        },
        "required": [
          "uri"
        ]
      },
      "DebtorIdentity": {
        "type": "object",
        "properties": {
          "uri": {
            "type": "string",
            "maxLength": 100,
            "format": "uri",
            "description": "The information contained in this field must be enough to uniquely and reliably identify the debtor. Note that a network request *should not be needed* to identify the debtor.\n\nFor example, if the issuer happens to be a bank, the URI would reveal the type of the issuer (a bank), the ID of the bank, and the currency code (USD for example). Note that some debtors may be used only to represent a physical value measurement unit (like ounces of gold). Those *dummy debtors* do not represent a person or an organization, do not owe anything to anyone, and are used solely as identifiers of value measurement units.",
            "example": "swpt:1"
          },
          "type": {
            "type": "string",
            "default": "DebtorIdentity",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "DebtorIdentity"
          }
        },
        "required": [
          "uri"
        ]
      },
      "PaginatedList": {
        "type": "object",
        "properties": {
          "itemsType": {
            "type": "string",
            "readOnly": true,
            "description": "The type of the items in the paginated list.",
            "example": "string"
          },
          "first": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of the first page in the paginated list. This can be a relative URI. The object retrieved from this URI will have: 1) An `items` field (an array), which will contain the first items of the paginated list; 2) May have a `next` field (a string), which would contain the URI of the next page in the list.",
            "example": "/list?page=1"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "PaginatedList"
          }
        },
        "required": [
          "first",
          "itemsType",
          "type"
        ]
      },
      "AccountLedger": {
        "type": "object",
        "properties": {
          "interest": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The approximate amount of interest accumulated on the account, which has not been added to the principal yet. This can be a negative number. Once in a while, the accumulated interest will be zeroed out and added to the principal (an interest payment).\n\n**Note:** The value of this field is calculated on-the-fly, so it may change from one request to another, and no `LogEntry` for the change will be added to the log.",
            "example": 0
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "entries": {
            "readOnly": true,
            "description": "A `PaginatedList` of account `LedgerEntry`s. That is: transfers for which the account is either the sender or the recipient. The paginated list will be sorted in reverse-chronological order (bigger `entryId`s go first).\n\n**Note:** Clients are allowed to add a `stop=KNOWN_ENTRY_ID` query parameter to the `entries.first` URI, informing the server that they do not need to receive ledger entries whose `entryId`s are smaller or equal (not newer) than `KNOWN_ENTRY_ID`. Servers MAY use this, so as not to access and return entries that will not be needed.",
            "example": {
              "itemsType": "LedgerEntry",
              "type": "PaginatedList",
              "first": "/creditors/2/accounts/1/entries?prev=124"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/PaginatedList"
              }
            ]
          },
          "nextEntryId": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The `entryID` of the next ledger entry to come. This will always be a positive number. The first ledger entry for each account will have an ID of `1`, and the ID of each subsequent ledger entry will be equal to the ID of the previous ledger entry plus one.",
            "example": 123
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountLedger"
          },
          "principal": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The principal amount on the account.",
            "example": 0
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/ledger"
          }
        },
        "required": [
          "account",
          "entries",
          "interest",
          "latestUpdateAt",
          "latestUpdateId",
          "nextEntryId",
          "principal",
          "type",
          "uri"
        ]
      },
      "DebtorInfo": {
        "type": "object",
        "properties": {
          "iri": {
            "type": "string",
            "maxLength": 200,
            "format": "iri",
            "description": "A link (Internationalized Resource Identifier) referring to a document containing information about the debtor.",
            "example": "https://example.com/debtors/1/"
          },
          "contentType": {
            "type": "string",
            "maxLength": 100,
            "description": "Optional MIME type of the document that the `iri` field refers to.",
            "example": "text/html"
          },
          "sha256": {
            "type": "string",
            "pattern": "^[0-9A-F]{64}$",
            "description": "Optional SHA-256 cryptographic hash (Base16 encoded) of the content of the document that the `iri` field refers to.",
            "example": "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"
          },
          "type": {
            "type": "string",
            "default": "DebtorInfo",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "DebtorInfo"
          }
        },
        "required": [
          "iri"
        ]
      },
      "AccountInfo": {
        "type": "object",
        "properties": {
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "noteMaxBytes": {
            "type": "integer",
            "readOnly": true,
            "format": "int32",
            "description": "The maximal number of bytes that transfer notes are allowed to contain when UTF-8 encoded. This will be a non-negative number.",
            "example": 500
          },
          "debtorInfo": {
            "readOnly": true,
            "description": "Optional information about the debtor.",
            "allOf": [
              {
                "$ref": "#/components/schemas/DebtorInfo"
              }
            ]
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "interestRateChangedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the latest change in the interest rate happened."
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "identity": {
            "readOnly": true,
            "description": "Account's `AccountIdentity`. It uniquely and reliably identifies the account when it participates in transfers as sender or recipient. When this field is not present, this means that the account does not have an identity yet (or anymore), and can not participate in transfers.\n\n**Note:** This field will not be present at all for *dummy accounts*. Dummy accounts can be useful for two purposes: 1) They can represent physical value measurement units (like ounces of gold), to which debtors can peg their currencies; 2) They can represent accounts with debtors to which no network connection is available, still allowing those accounts to act as links in a chain of currency pegs.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountInfo"
          },
          "interestRate": {
            "type": "number",
            "readOnly": true,
            "format": "float",
            "description": "Annual rate (in percents) at which interest accumulates on the account.",
            "example": 0.0
          },
          "safeToDelete": {
            "type": "boolean",
            "readOnly": true,
            "description": "Whether it is safe to delete this account. Will be `False` when `scheduledForDeletion` is `False`.",
            "example": false
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/info"
          },
          "configError": {
            "type": "string",
            "readOnly": true,
            "description": "When this field is present, this means that for some reason, the current `AccountConfig` settings can not be applied, or are not effectual anymore. Usually this means that there has been a network communication problem, or a system configuration problem. The value alludes to the cause of the problem.\n\n* `\"NO_CONNECTION_TO_DEBTOR\"` signifies that there is no network connection   to the account's debtor. Note that the account may still be useful as a   link in a chain of currency pegs.\n* `\"CONFIGURATION_IS_NOT_EFFECTUAL\"` signifies that the necessary confirmation   that the current configuration settings have been successfully applied   has not been received.\n",
            "example": "CONFIGURATION_IS_NOT_EFFECTUAL"
          }
        },
        "required": [
          "account",
          "interestRate",
          "interestRateChangedAt",
          "latestUpdateAt",
          "latestUpdateId",
          "noteMaxBytes",
          "safeToDelete",
          "type",
          "uri"
        ]
      },
      "AccountConfig": {
        "type": "object",
        "properties": {
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "allowUnsafeDeletion": {
            "type": "boolean",
            "description": "Whether unsafe deletion of the account is allowed by the creditor. Note that the deletion of an account which allows unsafe deletion may result in losing a non-negligible amount of money on the account.\n\n**Note:** For new accounts the value of this field will be `False`.",
            "example": false
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "scheduledForDeletion": {
            "type": "boolean",
            "description": "Whether the account is scheduled for deletion. The safest way to delete an account whose status (`AccountInfo`) indicates that deletion is not safe, is to first schedule it for deletion, and delete it only when the account status indicates that deletion is safe. Note that this may also require making outgoing transfers, so as to reduce the balance on the account to a negligible amount.\n\n**Note:** For new accounts the value of this field will be `False`.",
            "example": false
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "negligibleAmount": {
            "type": "number",
            "minimum": 0.0,
            "format": "float",
            "description": "The maximum amount that is considered negligible. It can be used to decide whether the account can be safely deleted, and whether an incoming transfer should be considered as insignificant. Must be non-negative.\n\n**Note:** For new accounts the value of this field will be `1e30`.",
            "example": 0.0
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "type": "string",
            "default": "AccountConfig",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountConfig"
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/config"
          }
        },
        "required": [
          "account",
          "allowUnsafeDeletion",
          "latestUpdateAt",
          "latestUpdateId",
          "negligibleAmount",
          "scheduledForDeletion",
          "uri"
        ]
      },
      "AccountDisplay": {
        "type": "object",
        "properties": {
          "amountDivisor": {
            "type": "number",
            "minimum": 0.0,
            "format": "double",
            "description": "Before displaying the amount, it should be divided by this number. For new accounts the value of this field will be `1`.\n\n**Note:** This value should be used for display purposes only. Notably, the value of this field must be ignored when the exchange rate  between pegged accounts is calculated.",
            "example": 100.0
          },
          "decimalPlaces": {
            "type": "integer",
            "minimum": -20,
            "maximum": 20,
            "format": "int32",
            "description": "The number of digits to show after the decimal point, when displaying the amount. A negative number signifies the number of insignificant digits at the end of the integer number. For new accounts the value of this field will be `0`.",
            "example": 2
          },
          "debtorName": {
            "type": "string",
            "minLength": 1,
            "maxLength": 40,
            "description": "The name of the debtor. All accounts belonging to a given creditor must have different `debtorName`s. The creditor may choose any name that is convenient, or easy to remember.\n\n**Note:** For new accounts this field will not be present, and it should be set as soon as possible, otherwise the real identity of the debtor may remain unknown to the creditor, which may lead to confusion and financial loses.",
            "example": "United States of America"
          },
          "unit": {
            "type": "string",
            "minLength": 1,
            "maxLength": 40,
            "description": "The value measurement unit specified by the debtor. It should be shown right after the displayed amount, \"500.00 USD\" for example. If the account does not have its `unit` field set, the generic currency sign (\u00a4), or the \"XXX\" ISO 4217 currency code should be shown.\n\n**Note:** For new accounts this field will not be present, and it should be set as soon as possible, otherwise the value measurement unit may remain unknown to the creditor, which may lead to confusion and financial loses.",
            "example": "USD"
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "type": "string",
            "default": "AccountDisplay",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountDisplay"
          },
          "knownDebtor": {
            "type": "boolean",
            "description": "Whether the account's debtor is known to the creditor. Accepting payments to accounts with an unknown debtor is of course very dangerous, but such accounts can still be useful as links in a chain of currency pegs. For new accounts the value of this field will be `False`.",
            "example": false
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/display"
          }
        },
        "required": [
          "account",
          "amountDivisor",
          "decimalPlaces",
          "knownDebtor",
          "latestUpdateAt",
          "latestUpdateId",
          "uri"
        ]
      },
      "CurrencyPeg": {
        "type": "object",
        "properties": {
          "exchangeRate": {
            "type": "number",
            "minimum": 0.0,
            "format": "double",
            "description": "The exchange rate between the pegged currency and the peg currency. For example, `2.0` would mean that pegged currency's tokens are twice as valuable as peg currency's tokens.",
            "example": 1.0
          },
          "account": {
            "description": "The URI of the peg currency's `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/11/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "type": {
            "type": "string",
            "default": "CurrencyPeg",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CurrencyPeg"
          }
        },
        "required": [
          "account",
          "exchangeRate"
        ]
      },
      "AccountExchange": {
        "type": "object",
        "properties": {
          "peg": {
            "description": "Optional `CurrencyPeg`. A currency peg is an exchange strategy in which the creditor sets a specific fixed exchange rate between the tokens of two of his accounts (the pegged currency, and the peg currency). Sometimes the peg currency is itself pegged to another currency. This is called a \"peg-chain\".",
            "allOf": [
              {
                "$ref": "#/components/schemas/CurrencyPeg"
              }
            ]
          },
          "policy": {
            "type": "string",
            "minLength": 1,
            "maxLength": 40,
            "description": "The name of the automatic exchange policy. If this field is not present, this means that the account will not participate in automatic exchanges. If the field is present, but the given policy name is not supported by the implementation, the implementation should behave as if `\"conservative\"` policy have been chosen.\n\n`\"conservative\"` is the most conservative exchange policy. It tries to make the *mimimal exchange* that would bring account's principal between `minPrincipal` and `maxPrincipal`, or if this is not possible, it tries to bring the principal as close as possible to that interval.\n\n**Note:** Different implementations may define additional exchange policies.",
            "example": "conservative"
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "maxPrincipal": {
            "type": "integer",
            "minimum": -9223372036854775808,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The principal amount on the account should not exceed this value. Note that this limit applies only for automatic exchanges, and is enforced on \"best effort\" basis. The value of this field must be greater or equal than the value of the `minPrincipal` field.\n\n**Note:** For new accounts the value of this field will be `9223372036854775807`.",
            "example": 5000
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "type": "string",
            "default": "AccountExchange",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountExchange"
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/exchange"
          },
          "minPrincipal": {
            "type": "integer",
            "minimum": -9223372036854775808,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The principal amount on the account should not fall below this value. Note that this limit applies only for automatic exchanges, and is enforced on \"best effort\" basis.\n\n**Note:** For new accounts the value of this field will be `-9223372036854775808`.",
            "example": 1000
          }
        },
        "required": [
          "account",
          "latestUpdateAt",
          "latestUpdateId",
          "maxPrincipal",
          "minPrincipal",
          "uri"
        ]
      },
      "AccountKnowledge": {
        "type": "object",
        "properties": {
          "interestRateChangedAt": {
            "type": "string",
            "format": "date-time",
            "description": "Optional moment at which the latest change in the interest rate has happened, which is known to the creditor."
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "identity": {
            "description": "Optional `AccountIdentity`, which is known to the creditor.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the corresponding `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "type": {
            "type": "string",
            "default": "AccountKnowledge",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "AccountKnowledge"
          },
          "configError": {
            "type": "string",
            "description": "Optional configuration error, which is known to the creditor.",
            "example": "CONFIGURATION_IS_NOT_EFFECTUAL"
          },
          "interestRate": {
            "type": "number",
            "format": "float",
            "description": "Optional annual account interest rate (in percents), which is known to the creditor.",
            "example": 0.0
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/knowledge"
          },
          "noteMaxBytes": {
            "type": "integer",
            "minimum": 0,
            "maximum": 500,
            "format": "int32",
            "description": "Optional maximal number of bytes that transfer notes are allowed to contain when UTF-8 encoded, which is known to the creditor.",
            "example": 500
          }
        },
        "required": [
          "account",
          "latestUpdateAt",
          "latestUpdateId",
          "uri"
        ],
        "additionalProperties": true
      },
      "Account": {
        "type": "object",
        "properties": {
          "ledger": {
            "readOnly": true,
            "description": "Account's `AccountLedger`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountLedger"
              }
            ]
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "info": {
            "readOnly": true,
            "description": "Account's `AccountInfo`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountInfo"
              }
            ]
          },
          "createdAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the account was created."
          },
          "config": {
            "readOnly": true,
            "description": "Account's `AccountConfig` settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountConfig"
              }
            ]
          },
          "debtor": {
            "readOnly": true,
            "description": "Account's `DebtorIdentity`.",
            "example": {
              "type": "DebtorIdentity",
              "uri": "swpt:1"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/DebtorIdentity"
              }
            ]
          },
          "display": {
            "readOnly": true,
            "description": "Account's `AccountDisplay` settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountDisplay"
              }
            ]
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "accountsList": {
            "readOnly": true,
            "description": "The URI of creditor's `AccountsList`.",
            "example": {
              "uri": "/creditors/2/accounts-list"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "exchange": {
            "readOnly": true,
            "description": "Account's `AccountExchange` settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountExchange"
              }
            ]
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "Account"
          },
          "knowledge": {
            "readOnly": true,
            "description": "Account's `AccountKnowledge` settings.",
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountKnowledge"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/"
          }
        },
        "required": [
          "accountsList",
          "config",
          "createdAt",
          "debtor",
          "display",
          "exchange",
          "info",
          "knowledge",
          "latestUpdateAt",
          "latestUpdateId",
          "ledger",
          "type",
          "uri"
        ]
      },
      "LedgerEntry": {
        "type": "object",
        "properties": {
          "ledger": {
            "readOnly": true,
            "description": "The URI of the corresponding `AccountLedger`.",
            "example": {
              "uri": "/creditors/2/accounts/1/ledger"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "addedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the entry was added to the ledger."
          },
          "acquiredAmount": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The amount added to the account's principal. Can be a positive number (an increase), a negative number (a decrease), or zero.",
            "example": 1000
          },
          "entryId": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The ID of the ledger entry. This will always be a positive number. The ID of the first ledger entry for a given account can be any positive number, but the IDs of all subsequent ledger entries will be equal to the ID of the previous ledger entry plus one. When an account has been deleted and recreated again, the first (the smallest) ledger entry ID for the new account is guaranteed to be larger than the last (the largest) entry ID for the deleted account, and the difference is guaranteed to be at least 2 (a gap will exist).",
            "example": 12345
          },
          "principal": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The new principal amount on the account, as it is after the transfer. Unless a principal overflow has occurred, the new principal amount will be equal to `acquiredAmount` plus the old principal amount.",
            "example": 1500
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "LedgerEntry"
          },
          "transfer": {
            "readOnly": true,
            "description": "Optional URI of the corresponding `CommittedTransfer`. When this field is not present, this means that the ledger entry compensates for one or more negligible transfers.",
            "example": {
              "uri": "/creditors/2/accounts/1/transfers/18444-999"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          }
        },
        "required": [
          "acquiredAmount",
          "addedAt",
          "entryId",
          "ledger",
          "principal",
          "type"
        ]
      },
      "LedgerEntriesPage": {
        "type": "object",
        "properties": {
          "next": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "An URI of another `LedgerEntriesPage` object which contains more items. When there are no remaining items, this field will not be present. If this field is present, there might be remaining items, even when the `items` array is empty. This can be a relative URI."
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/entries?prev=124"
          },
          "items": {
            "readOnly": true,
            "description": "An array of `LedgerEntry`s. Can be empty.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/LedgerEntry"
            }
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "LedgerEntriesPage"
          }
        },
        "required": [
          "items",
          "type",
          "uri"
        ]
      },
      "TransferOptions": {
        "type": "object",
        "properties": {
          "lockedAmount": {
            "type": "integer",
            "default": 0,
            "minimum": 0,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The amount that should to be locked when the transer is prepared. This must be a non-negative number.",
            "example": 0
          },
          "deadline": {
            "type": "string",
            "format": "date-time",
            "description": "The transfer will be successful only if it is committed before this moment. This can be useful, for example, when the transferred amount may need to be changed if the transfer can not be committed in time. When this field is not present, this means that the deadline for the transfer will not be earlier than normal."
          },
          "minInterestRate": {
            "type": "number",
            "default": -100.0,
            "minimum": -100.0,
            "format": "float",
            "description": "The minimal approved interest rate. If the interest rate on the account becomes lower than this value, the transfer will not be successful. This can be useful when the transferred amount may need to be decreased if the interest rate on the account has decreased.",
            "example": -100.0
          },
          "type": {
            "type": "string",
            "default": "TransferOptions",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransferOptions"
          }
        }
      },
      "TransferCreationRequest": {
        "type": "object",
        "properties": {
          "recipient": {
            "description": "The recipient's `AccountIdentity` information.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2222"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "note": {
            "type": "string",
            "default": "",
            "maxLength": 500,
            "description": "A note from the sender. Can be any string that contains information which the sender wants the recipient to see, including an empty string.",
            "example": "Hello, World!"
          },
          "options": {
            "description": "Optional `TransferOptions`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferOptions"
              }
            ]
          },
          "noteFormat": {
            "type": "string",
            "default": "",
            "pattern": "^[0-9A-Za-z.-]{0,8}$",
            "description": "The format used for the `note` field. An empty string signifies unstructured text.",
            "example": ""
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "type": "string",
            "default": "TransferCreationRequest",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransferCreationRequest"
          },
          "transferUuid": {
            "type": "string",
            "format": "uuid",
            "description": "A client-generated UUID for the transfer.",
            "example": "123e4567-e89b-12d3-a456-426655440000"
          },
          "amount": {
            "type": "integer",
            "minimum": 0,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The amount that has to be transferred. Must be a non-negative number. Setting this value to zero can be useful when the sender wants to verify whether the recipient's account exists and accepts incoming transfers.",
            "example": 1000
          }
        },
        "required": [
          "amount",
          "recipient",
          "transferUuid"
        ]
      },
      "TransferError": {
        "type": "object",
        "properties": {
          "errorCode": {
            "type": "string",
            "readOnly": true,
            "description": "The error code.\n\n* `\"CANCELED_BY_THE_SENDER\"` signifies that the transfer has been   canceled by the sender.\n* `\"SENDER_DOES_NOT_EXIST\"` signifies that the sender's account   does not exist.\n* `\"RECIPIENT_IS_UNREACHABLE\"` signifies that the recipient's  account does not exist, or does not accept incoming transfers.\n* `\"TRANSFER_NOTE_IS_TOO_LONG\"` signifies that the transfer has been   rejected because the byte-length of the transfer note is too big.\n* `\"INSUFFICIENT_AVAILABLE_AMOUNT\"` signifies that the transfer   has been rejected due to insufficient amount available on the   sender's account.\n* `\"TERMINATED\"` signifies that the transfer has been terminated   due to expired deadline, unapproved interest rate change, or   some other *temporary or correctable condition*. If the client   verifies the transer options and retries the transfer, chances   are that it will be committed successfully.\n",
            "example": "INSUFFICIENT_AVAILABLE_AMOUNT"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransferError"
          },
          "totalLockedAmount": {
            "readOnly": true,
            "type": "integer",
            "format": "int64",
            "description": "This field will be present only when the transfer has been rejected due to insufficient available amount. In this case, it will contain the total sum secured (locked) for transfers on the account, *after* this transfer has been finalized.",
            "example": 0
          }
        },
        "required": [
          "errorCode",
          "type"
        ]
      },
      "TransferResult": {
        "type": "object",
        "properties": {
          "error": {
            "readOnly": true,
            "description": "An error that has occurred during the execution of the transfer. This field will be present if, and only if, the transfer has been unsuccessful.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferError"
              }
            ]
          },
          "finalizedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the transfer was finalized."
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransferResult"
          },
          "committedAmount": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The transferred amount. If the transfer has been successful, the value will be equal to the requested transfer amount (always a positive number). If the transfer has been unsuccessful, the value will be zero.",
            "example": 0
          }
        },
        "required": [
          "committedAmount",
          "finalizedAt",
          "type"
        ]
      },
      "Transfer": {
        "type": "object",
        "properties": {
          "recipient": {
            "description": "The recipient's `AccountIdentity` information.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2222"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "note": {
            "type": "string",
            "readOnly": true,
            "description": "A note from the sender. Can be any string that contains information which the sender wants the recipient to see, including an empty string.",
            "example": "Hello, World!"
          },
          "latestUpdateId": {
            "type": "integer",
            "minimum": 1,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The sequential number of the latest update in the object. This will always be a positive number, which gets incremented after each change in the object. Normally the counting starts from `1`, but this is not guaranteed. For objects that can be deleted and re-created with the same URI (accounts for example), the counting will start with some arbitrary number that is guaranteed to be bigger than the number the previous \"generation\" finished with.\n\nWhen the object is changed by the server, the value of this field will be incremented automatically, and will be equal to the value of the `objectUpdateId` field in the latest `LogEntry` for this object in the log. In this case, the value of the field can be used by the client to decide whether a network request should be made to obtain the newest state of the object.\n\nWhen the object is changed by the client, the value of this field must be incremented by the client. In this case, the server will use the value of the field to detect conflicts which can occur when two clients try to update the object simultaneously.",
            "example": 123
          },
          "checkupAt": {
            "readOnly": true,
            "type": "string",
            "format": "date-time",
            "description": "The moment at which the sender is advised to look at the transfer again, to see if it's status has changed. If this field is not present, this means either that the status of the transfer is not expected to change, or that the moment of the expected change can not be predicted.\n\n**Note:** The value of this field is calculated on-the-fly, so it may change from one request to another, and no `LogEntry` for the change will be added to the log."
          },
          "options": {
            "readOnly": true,
            "description": "Transfer's `TransferOptions`.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferOptions"
              }
            ]
          },
          "latestUpdateAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment of the latest update on this object. The value is the same as the value of the `addedAt` field in the latest `LogEntry` for this object in the log."
          },
          "initiatedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the transfer was initiated."
          },
          "noteFormat": {
            "type": "string",
            "readOnly": true,
            "pattern": "^[0-9A-Za-z.-]{0,8}$",
            "description": "The format used for the `note` field. An empty string signifies unstructured text.",
            "example": ""
          },
          "pin": {
            "type": "string",
            "writeOnly": true,
            "pattern": "^[0-9]{4,10}$",
            "description": "Optional PIN (Personal Identification Number).\n\n**Note:** This field must be present when the PIN is required for potentially dangerous operations. In such cases, if the passed value is incorrect, the operation will fail. After several such failed attempts, the creditor's PIN will be blocked.",
            "example": "1234"
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "Transfer"
          },
          "transfersList": {
            "readOnly": true,
            "description": "The URI of creditor's `TransfersList`.",
            "example": {
              "uri": "/creditors/2/transfers-list"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "result": {
            "readOnly": true,
            "description": "Contains information about the outcome of the transfer. This field will be preset if, and only if, the transfer has been finalized. Note that a finalized transfer can be either successful, or unsuccessful.",
            "allOf": [
              {
                "$ref": "#/components/schemas/TransferResult"
              }
            ]
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/transfers/123e4567-e89b-12d3-a456-426655440000"
          },
          "transferUuid": {
            "type": "string",
            "format": "uuid",
            "description": "A client-generated UUID for the transfer.",
            "example": "123e4567-e89b-12d3-a456-426655440000"
          },
          "amount": {
            "type": "integer",
            "minimum": 0,
            "maximum": 9223372036854775807,
            "format": "int64",
            "description": "The amount that has to be transferred. Must be a non-negative number. Setting this value to zero can be useful when the sender wants to verify whether the recipient's account exists and accepts incoming transfers.",
            "example": 1000
          }
        },
        "required": [
          "amount",
          "initiatedAt",
          "latestUpdateAt",
          "latestUpdateId",
          "note",
          "noteFormat",
          "options",
          "recipient",
          "transferUuid",
          "transfersList",
          "type",
          "uri"
        ]
      },
      "TransferCancelationRequest": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "default": "TransferCancelationRequest",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "TransferCancelationRequest"
          }
        }
      },
      "CommittedTransfer": {
        "type": "object",
        "properties": {
          "recipient": {
            "readOnly": true,
            "description": "The recipient's `AccountIdentity` information.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2222"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "rationale": {
            "type": "string",
            "readOnly": true,
            "description": "This field will be present only for system transfers. Its value indicates the subsystem which originated the transfer. For interest payments the value will be `\"interest\"`. For transfers that create new money into existence, the value will be `\"issuing\"`.",
            "example": "interest"
          },
          "note": {
            "type": "string",
            "readOnly": true,
            "description": "A note from the committer of the transfer. Can be any string that contains information which whoever committed the transfer wants the recipient (and the sender) to see. Can be an empty string.",
            "example": ""
          },
          "acquiredAmount": {
            "type": "integer",
            "readOnly": true,
            "format": "int64",
            "description": "The amount that this transfer has added to the account's principal. This can be a positive number (an incoming transfer), a negative number (an outgoing transfer), but can not be zero.",
            "example": 1000
          },
          "sender": {
            "readOnly": true,
            "description": "The sender's `AccountIdentity` information.",
            "example": {
              "type": "AccountIdentity",
              "uri": "swpt:1/2"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/AccountIdentity"
              }
            ]
          },
          "account": {
            "readOnly": true,
            "description": "The URI of the affected `Account`.",
            "example": {
              "uri": "/creditors/2/accounts/1/"
            },
            "allOf": [
              {
                "$ref": "#/components/schemas/ObjectReference"
              }
            ]
          },
          "noteFormat": {
            "type": "string",
            "readOnly": true,
            "pattern": "^[0-9A-Za-z.-]{0,8}$",
            "description": "The format used for the `note` field. An empty string signifies unstructured text.",
            "example": ""
          },
          "type": {
            "readOnly": true,
            "type": "string",
            "description": "The type of this object. Will always be present in the responses from the server.",
            "example": "CommittedTransfer"
          },
          "committedAt": {
            "type": "string",
            "format": "date-time",
            "readOnly": true,
            "description": "The moment at which the transfer was committed."
          },
          "uri": {
            "type": "string",
            "readOnly": true,
            "format": "uri-reference",
            "description": "The URI of this object. Can be a relative URI.",
            "example": "/creditors/2/accounts/1/transfers/18444-999"
          }
        },
        "required": [
          "account",
          "acquiredAmount",
          "committedAt",
          "note",
          "noteFormat",
          "recipient",
          "sender",
          "type",
          "uri"
        ]
      }
    },
    "responses": {
      "UNPROCESSABLE_ENTITY": {
        "description": "Unprocessable Entity",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      },
      "DEFAULT_ERROR": {
        "description": "Default error response",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/Error"
            }
          }
        }
      }
    }
  },
  "paths": {
    "/creditors/.creditor-reserve": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditorReservation"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "409": {
            "description": "A creditor with the same ID already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditorReservationRequest"
              }
            }
          }
        },
        "summary": "Reserve an auto-generated creditor ID.",
        "description": "**Note:** The reserved creditor ID will be a random valid\ncreditor ID.",
        "tags": [
          "admin"
        ],
        "operationId": "reserveRandomCreditor",
        "security": [
          {
            "oauth2": [
              "activate"
            ]
          }
        ]
      }
    },
    "/creditors/.list": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditorsList"
                },
                "example": {
                  "type": "CreditorsList",
                  "uri": "/creditors/.list",
                  "itemsType": "ObjectReference",
                  "first": "/creditors/9223372036854775808/enumerate"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a paginated list of links to all active creditors.",
        "tags": [
          "admin"
        ],
        "operationId": "getCreditorsList",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      }
    },
    "/creditors/{creditorId}/enumerate": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectReferencesPage"
                },
                "example": {
                  "uri": "/creditors/2/enumerate",
                  "type": "ObjectReferencesPage",
                  "items": [
                    {
                      "uri": "/creditors/2/"
                    },
                    {
                      "uri": "/creditors/5/"
                    },
                    {
                      "uri": "/creditors/11/"
                    }
                  ],
                  "next": "/creditors/12/enumerate"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a collection of active creditors.",
        "description": "The returned object will be a fragment (a page) of a paginated\nlist. The paginated list contains references to all active\ncreditors on the server. The returned fragment, and all the\nsubsequent fragments, will be sorted by creditor ID, starting\nfrom the `creditorID` specified in the path. The sorting order\nis implementation-specific.\n\n**Note:** To obtain references to all active creditors, the\nclient should start with the creditor ID that precedes all\nother IDs in the sorting order.",
        "tags": [
          "admin"
        ],
        "operationId": "getCreditorsPage",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/reserve": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreditorReservation"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "409": {
            "description": "A creditor with the same ID already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditorReservationRequest"
              }
            }
          }
        },
        "summary": "Try to reserve a specific creditor ID.",
        "description": "**Note:** The reserved creditor ID will be the same as the\n`creditorId` specified in the path.",
        "tags": [
          "admin"
        ],
        "operationId": "reserveCreditor",
        "security": [
          {
            "oauth2": [
              "activate"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/activate": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Creditor"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "409": {
            "description": "A creditor with the same ID already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditorActivationRequest"
              }
            }
          }
        },
        "summary": "Activate a creditor.",
        "tags": [
          "admin"
        ],
        "operationId": "activateCreditor",
        "security": [
          {
            "oauth2": [
              "activate"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/deactivate": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "204": {
            "description": "No Content"
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/CreditorDeactivationRequest"
              }
            }
          }
        },
        "summary": "Deactivate a creditor.",
        "tags": [
          "admin"
        ],
        "operationId": "deactivateCreditor",
        "security": [
          {
            "oauth2": [
              "deactivate"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/.wallet": {
      "get": {
        "responses": {
          "204": {
            "description": "The wallet has not been found."
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "303": {
            "description": "The wallet has been found.",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            }
          }
        },
        "summary": "Redirect to the creditor's wallet.",
        "tags": [
          "creditors"
        ],
        "operationId": "redirectToWallet",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      }
    },
    "/creditors/{creditorId}/": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Creditor"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a creditor.",
        "tags": [
          "creditors"
        ],
        "operationId": "getCreditor",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/wallet": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Wallet"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return creditor's wallet.",
        "description": "The creditor's wallet \"contains\" all creditor's accounts,\npending transfers, and recent events (the log). In short: it\nis the gateway to all objects and operations in the API.",
        "tags": [
          "creditors"
        ],
        "operationId": "getWallet",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/pin": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PinInfo"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return creditor's PIN information.",
        "tags": [
          "creditors"
        ],
        "operationId": "getPinInfo",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "patch": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PinInfo"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/PinInfo"
              }
            }
          }
        },
        "summary": "Update creditor's PIN information.",
        "description": "**Note:** This is a potentially dangerous operation which may\nrequire a PIN. Also, normally this is an idempotent operation,\nbut when an incorrect PIN is supplied, repeating the operation\nmay result in the creditor's PIN being blocked.",
        "tags": [
          "creditors"
        ],
        "operationId": "updatePinInfo",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/log": {
      "get": {
        "parameters": [
          {
            "in": "query",
            "name": "prev",
            "required": false,
            "description": "Start with the item that follows the item with this index.",
            "schema": {
              "type": "integer",
              "default": 0,
              "writeOnly": true,
              "minimum": 0,
              "maximum": 9223372036854775807,
              "format": "int64",
              "example": 1
            }
          }
        ],
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LogEntriesPage"
                },
                "example": {
                  "uri": "/creditors/2/log",
                  "type": "LogEntriesPage",
                  "items": [
                    {
                      "type": "LogEntry",
                      "entryId": 12345,
                      "addedAt": "2020-04-06T14:22:11Z",
                      "objectType": "Account",
                      "object": {
                        "uri": "/creditors/2/accounts/1/"
                      },
                      "objectUpdateId": 10,
                      "deleted": false
                    }
                  ],
                  "forthcoming": "?prev=12345"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a collection of creditor's recent log entries.",
        "description": "The returned object will be a fragment (a page) of a paginated\nlist. The paginated list contains recent log entries. The\nreturned fragment, and all the subsequent fragments, will be\nsorted in chronological order (smaller `entryId`s go\nfirst).\n\n**Note:** The number of items in the returned fragment should\nbe small enough, so that all the items in the fragment can be\nprocessed and saved to the client's local database in a single\ndatabase transaction.",
        "tags": [
          "creditors"
        ],
        "operationId": "getLogPage",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts-list": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountsList"
                },
                "example": {
                  "wallet": {
                    "uri": "/creditors/2/wallet"
                  },
                  "type": "AccountsList",
                  "uri": "/creditors/2/accounts-list",
                  "first": "/creditors/2/accounts/",
                  "itemsType": "ObjectReference",
                  "latestUpdateId": 777,
                  "latestUpdateAt": "2020-06-20T18:53:43Z"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a paginated list of links to all accounts belonging to a\ncreditor.",
        "description": "The paginated list will not be sorted in any particular order.",
        "tags": [
          "creditors"
        ],
        "operationId": "getAccountsList",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/transfers-list": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/TransfersList"
                },
                "example": {
                  "wallet": {
                    "uri": "/creditors/2/wallet"
                  },
                  "type": "TransfersList",
                  "uri": "/creditors/2/transfers-list",
                  "first": "/creditors/2/transfers/",
                  "itemsType": "ObjectReference",
                  "latestUpdateId": 778,
                  "latestUpdateAt": "2020-06-20T18:53:43Z"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a paginated list of links to all transfers belonging to a\ncreditor.",
        "description": "The paginated list will not be sorted in any particular order.",
        "tags": [
          "creditors"
        ],
        "operationId": "getTransfersList",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/account-lookup": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/DebtorIdentity"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountIdentity"
              },
              "example": {
                "type": "AccountIdentity",
                "uri": "swpt:1/2222"
              }
            }
          }
        },
        "summary": "Given an account identity, find the debtor's identity.",
        "description": "This can be useful, for example, when the creditor wants to\nsend money to some other creditor's account, but he does not\nknow if he already has an account with the same debtor (that\nis: the debtor of the other creditor's account).",
        "tags": [
          "accounts"
        ],
        "operationId": "accountLookup",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/debtor-lookup": {
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "204": {
            "description": "Account does not exist."
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "303": {
            "description": "Account exists.",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DebtorIdentity"
              },
              "example": {
                "type": "DebtorIdentity",
                "uri": "swpt:1"
              }
            }
          }
        },
        "summary": "Try to find an existing account with a given debtor.",
        "description": "This is useful when the creditor wants not know if he already\nhas an account with a given debtor.\n\n**Note:** A 422 error will be returned when the debtor's\nidentity can not be recognized.",
        "tags": [
          "accounts"
        ],
        "operationId": "debtorLookup",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/": {
      "get": {
        "parameters": [
          {
            "in": "query",
            "name": "prev",
            "required": false,
            "description": "The returned fragment will begin with the first account that follows the account whose debtor ID is equal to value of this parameter.",
            "schema": {
              "type": "string",
              "writeOnly": true,
              "pattern": "^[0-9A-Za-z_=-]{1,64}$",
              "example": "1"
            }
          }
        ],
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectReferencesPage"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a collection of accounts belonging to a given creditor.",
        "description": "The returned object will be a fragment (a page) of a paginated\nlist. The paginated list contains references to all `Account`s\nbelonging to a given creditor. The returned fragment will not\nbe sorted in any particular order.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountsPage",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "201": {
            "description": "Created",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "303": {
            "description": "Account exists.",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/DebtorIdentity"
              },
              "example": {
                "type": "DebtorIdentity",
                "uri": "swpt:1"
              }
            }
          }
        },
        "summary": "Create account.",
        "description": "**Note:** This is an idempotent operation.",
        "tags": [
          "accounts"
        ],
        "operationId": "createAccount",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Account"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account.",
        "description": "The returned `Account` object encompasses all the avilable\ninformation for a particular account. This includes the\nfollwing sub-objects:\n\n* `AccountConfig`\n* `AccountLedger`\n* `AccountInfo`\n* `AccountDisplay`\n* `AccountExchange`\n* `AccountKnowledge`\n\nNote that when one of those sub-objects gets changed, a\n`LogEntry` for the change in the particular sub-object will be\nadded to the log, but a `LogEntry` for the change in the\nencompassing `Account` object *will not be added to the log*.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccount",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "delete": {
        "responses": {
          "204": {
            "description": "No Content"
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "Forbidden account deletion.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "summary": "Delete account.",
        "description": "This operation will succeed only if all of the following\nconditions are true:\n\n1. There are no other accounts pegged to this account.\n\n2. The account is marked as safe for deletion, or unsafe\n   deletion is allowed for the account, or a `debtorName` has\n   not been set for the account.",
        "tags": [
          "accounts"
        ],
        "operationId": "deleteAccount",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/config": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountConfig"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account's configuration.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountConfig",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "patch": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountConfig"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountConfig"
              }
            }
          }
        },
        "summary": "Update account's configuration.",
        "description": "**Note:** This is a potentially dangerous operation which may\nrequire a PIN. Also, normally this is an idempotent operation,\nbut when an incorrect PIN is supplied, repeating the operation\nmay result in the creditor's PIN being blocked.",
        "tags": [
          "accounts"
        ],
        "operationId": "updateAccountConfig",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/display": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountDisplay"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account's display settings.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountDisplay",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "patch": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountDisplay"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountDisplay"
              }
            }
          }
        },
        "summary": "Update account's display settings.",
        "description": "A 422 error will be returned if there is another account with\nthe same `debtorName`.\n\n**Note:** This is a potentially dangerous operation which may\nrequire a PIN. Also, normally this is an idempotent operation,\nbut when an incorrect PIN is supplied, repeating the operation\nmay result in the creditor's PIN being blocked.",
        "tags": [
          "accounts"
        ],
        "operationId": "updateAccountDisplay",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/exchange": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountExchange"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account's exchange settings.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountExchange",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "patch": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountExchange"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountExchange"
              }
            }
          }
        },
        "summary": "Update account's exchange settings.",
        "description": "**Note:** This is a potentially dangerous operation which may\nrequire a PIN. Also, normally this is an idempotent operation,\nbut when an incorrect PIN is supplied, repeating the operation\nmay result in the creditor's PIN being blocked.",
        "tags": [
          "accounts"
        ],
        "operationId": "updateAccountExchange",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/knowledge": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountKnowledge"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "summary": "Return account's stored knowledge.",
        "description": "The returned object contains previously stored knowledge about\nthe account.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountKnowledge",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "patch": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountKnowledge"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "409": {
            "description": "Conflicting update attempts.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/AccountKnowledge"
              }
            }
          }
        },
        "summary": "Update account's stored knowledge.",
        "description": "This operation should be performed when an important knowledge\nabout the account needs to be stored. In addition to the\nproperties defined in the `AccountKnowledge` schema, the\npassed object may contain any other properties, which will be\nstored as well. The total length of the stored data can not\nexceed 8000 bytes (JSON, UTF-8 encoded, excluding `type` and\n`latestUpdateId` properties).\n\n**Example:** To be able to detect a change in the interest\nrate on the account, the client application can use this\nendpoint to store the interest rate acknowledged by the user,\nand later, compare the stored value with the current interest\nrate on the account. This way, the change in the interest rate\nwill be correctly detected, even if the user uses several\ndifferent client devices (or applications).",
        "tags": [
          "accounts"
        ],
        "operationId": "updateAccountKnowledge",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/info": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountInfo"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account's status information.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountInfo",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/ledger": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/AccountLedger"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return account's ledger.",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountLedger",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/entries": {
      "get": {
        "parameters": [
          {
            "in": "query",
            "name": "stop",
            "required": false,
            "description": "The returned fragment, and all the subsequent fragments, will contain only ledger entries whose `entryId` is bigger (newer) than the value of this parameter. This can be used to prevent repeatedly receiving ledger entries that the client already knows about.",
            "schema": {
              "type": "integer",
              "default": 0,
              "writeOnly": true,
              "minimum": 0,
              "maximum": 9223372036854775807,
              "format": "int64",
              "example": 50
            }
          },
          {
            "in": "query",
            "name": "prev",
            "required": true,
            "description": "The returned fragment will begin with the latest ledger entry for the given account, whose `entryId` is smaller (older) than the value of this parameter.",
            "schema": {
              "type": "integer",
              "writeOnly": true,
              "minimum": 0,
              "maximum": 9223372036854775807,
              "format": "int64",
              "example": 100
            }
          }
        ],
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/LedgerEntriesPage"
                },
                "example": {
                  "uri": "/creditors/2/accounts/1/entries?prev=124",
                  "type": "LedgerEntriesPage",
                  "items": [
                    {
                      "type": "LedgerEntry",
                      "ledger": {
                        "uri": "/creditors/2/accounts/1/ledger"
                      },
                      "transfer": {
                        "uri": "/creditors/2/accounts/1/transfers/18444-999"
                      },
                      "entryId": 123,
                      "addedAt": "2020-04-03T18:42:44Z",
                      "principal": 1500,
                      "acquiredAmount": 1000
                    }
                  ],
                  "next": "?prev=123"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a collection of ledger entries for a given account.",
        "description": "The returned object will be a fragment (a page) of a paginated\nlist. The paginated list contains ledger entries for a given\naccount. The returned fragment, and all the subsequent\nfragments, will be sorted in reverse-chronological order\n(bigger `entryId`s go first).",
        "tags": [
          "accounts"
        ],
        "operationId": "getAccountLedgerEntriesPage",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/transfers/": {
      "get": {
        "parameters": [
          {
            "in": "query",
            "name": "prev",
            "required": false,
            "description": "The returned fragment will begin with the first transfer that follows the transfer whose transfer UUID is equal to value of this parameter.",
            "schema": {
              "type": "string",
              "format": "uuid",
              "writeOnly": true,
              "example": "123e4567-e89b-12d3-a456-426655440000"
            }
          }
        ],
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ObjectReferencesPage"
                },
                "example": {
                  "next": "?prev=00112233-4455-6677-8899-aabbccddeeff",
                  "items": [
                    {
                      "uri": "123e4567-e89b-12d3-a456-426655440000"
                    },
                    {
                      "uri": "00112233-4455-6677-8899-aabbccddeeff"
                    }
                  ],
                  "uri": "/creditors/2/transfers/",
                  "type": "ObjectReferencesPage"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a collection of transfers, initiated by a given creditor.",
        "description": "The returned object will be a fragment (a page) of a paginated\nlist. The paginated list contains references to all transfers\ninitiated by a given creditor, which have not been deleted\nyet. The returned fragment will not be sorted in any\nparticular order.",
        "tags": [
          "transfers"
        ],
        "operationId": "getTransfersPage",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "201": {
            "description": "Created",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            },
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transfer"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "303": {
            "description": "The same transfer entry already exists.",
            "headers": {
              "Location": {
                "description": "The URI of the entry.",
                "schema": {
                  "type": "string",
                  "format": "uri"
                }
              }
            }
          },
          "403": {
            "description": "Forbidden operation.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          },
          "409": {
            "description": "A different transfer entry with the same UUID already exists.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferCreationRequest"
              }
            }
          }
        },
        "summary": "Initiate a transfer.",
        "description": "**Note:** This is a potentially dangerous operation which may\nrequire a PIN. Also, normally this is an idempotent operation,\nbut when an incorrect PIN is supplied, repeating the operation\nmay result in the creditor's PIN being blocked.",
        "tags": [
          "transfers"
        ],
        "operationId": "createTransfer",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    },
    "/creditors/{creditorId}/transfers/{transferUuid}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transfer"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return a transfer.",
        "tags": [
          "transfers"
        ],
        "operationId": "getTransfer",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "post": {
        "responses": {
          "422": {
            "$ref": "#/components/responses/UNPROCESSABLE_ENTITY"
          },
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/Transfer"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          },
          "403": {
            "description": "The transfer can not be canceled.",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int32",
                      "description": "Error code"
                    },
                    "errors": {
                      "type": "object",
                      "description": "Errors"
                    },
                    "status": {
                      "type": "string",
                      "description": "Error name"
                    },
                    "message": {
                      "type": "string",
                      "description": "Error message"
                    }
                  }
                }
              }
            }
          }
        },
        "requestBody": {
          "required": true,
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/TransferCancelationRequest"
              }
            }
          }
        },
        "summary": "Try to cancel a transfer.",
        "description": "**Note:** This is an idempotent operation.",
        "tags": [
          "transfers"
        ],
        "operationId": "cancelTransfer",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "delete": {
        "responses": {
          "204": {
            "description": "No Content"
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Delete a transfer.",
        "description": "Before deleting a transfer, client implementations should\nensure that at least 5 days (120 hours) have passed since the\ntransfer was initiated (see the `initiatedAt` field). Also, it\nis recommended successful transfers to stay on the server at\nleast a few weeks after their finalization.\n\nNote that deleting a running (not finalized) transfer does not\ncancel it. To ensure that a running transfer has not been\nsuccessful, it must be canceled before deletion.",
        "tags": [
          "transfers"
        ],
        "operationId": "deleteTransfer",
        "security": [
          {
            "oauth2": [
              "access"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "transferUuid",
          "required": true,
          "description": "The transfer's UUID",
          "schema": {
            "type": "string",
            "format": "uuid"
          }
        }
      ]
    },
    "/creditors/{creditorId}/accounts/{debtorId}/transfers/{transferId}": {
      "get": {
        "responses": {
          "200": {
            "description": "OK",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CommittedTransfer"
                }
              }
            }
          },
          "default": {
            "$ref": "#/components/responses/DEFAULT_ERROR"
          }
        },
        "summary": "Return information about sent or received transfer.",
        "description": "Note that the creditor can be either the sender of the\nrecipient of the transfer.",
        "tags": [
          "transfers"
        ],
        "operationId": "getCommittedTransfer",
        "security": [
          {
            "oauth2": [
              "access.readonly"
            ]
          }
        ]
      },
      "parameters": [
        {
          "in": "path",
          "name": "creditorId",
          "required": true,
          "description": "The creditor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "debtorId",
          "required": true,
          "description": "The debtor's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        },
        {
          "in": "path",
          "name": "transferId",
          "required": true,
          "description": "The transfer's ID",
          "schema": {
            "type": "string",
            "pattern": "^[0-9A-Za-z_=-]{1,64}$"
          }
        }
      ]
    }
  },
  "tags": [
    {
      "name": "admin",
      "description": "**View creditors list, create new creditors, deactivate inactive\n    creditors.** The creation of new creditors can optionally be done\n    in two-phases: First a creditor ID can be *reserved*, and only\n    then, the creditor can be *activated*. This is useful when the\n    client wants to know the new creditor ID in advance. If this is\n    not needed, the creditor can also be activated directly, by a\n    single request."
    },
    {
      "name": "creditors",
      "description": "**Obtain information about existing creditors, change creditors'\n    PINs.** There are two important concepts here: Each creditor has a\n    *\"wallet\"*, which contains references to various kinds of\n    information about the creditor (like creditor's list of accounts\n    and transfers). The other important concept is the creditor's\n    *\"log\"*. Whenever there is new information that the creditor\n    should be aware of, a record will be added to the creditor's log,\n    referring to the created/updated/deleted object. The purpose of\n    the log is to allow the clients of the API to reliably synchronize\n    their local databases with the server, simply by following the\n    \"log\"."
    },
    {
      "name": "accounts",
      "description": "**Create, view, update, and delete accounts. View accounts'\n    ledgers.** Every account record consists of a \"master\" account\n    object, which contains references to several account sub-objects\n    (account configuration, account status, account ledger etc). Each\n    of these sub-objects contain different kind of information about\n    the account, and each sub-object can be updated separately."
    },
    {
      "name": "transfers",
      "description": "**Make transfers from one account to another account.** A new\n    transfer record will be created for every initiated transfer. The\n    client itself is responsible for the deletion of each transfer\n    record, once the client does not need it anymore. Sometime after\n    the transfer has been initiated, it will be automatically\n    finalized as either successful or unsuccessful. Changes in the\n    statuses of transfer records will be recorded to the corresponding\n    creditor's \"log\". Note that the client may try to cancel an\n    erroneously initiated transfer, but there are no guarantees for\n    success."
    }
  ],
  "openapi": "3.0.2"
}
